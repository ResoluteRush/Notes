
I was working on trying to understand what metasolvers (a system composing solvers in a flexible way) might look like and that involved thinking about flexible systems again

---

Here's a verbatim excerpt from my notes, may be incomprehensible. This was just an effort to explore the idea some more and ideate. I was trying to only consider things that could actually be automated now, to manage a faultfull situation, without any human intervention...

You're in a train station and you want to get a ticket so you take out your phone and scan a code on one of the computers at the station. Your phone doesn't recognize the code so it might look online and load a new classifier and program to read this code, or maybe it does a search of other classifiers and programs in its own memory and finds one that works. It determines automatically that it is a bar code, despite it expecting a qr code. The data the code is interpreted to then can be used. And the phone's memory is *sticky* in that it remembers: 'I scanned this this code and couldn't recognize it at first, so I did a search and found it was a bar code, the data after running the program is ..., and this was at an unknown precise location, the wifi ssids were ..., and their signal strengths were ..., a shortrange bluetooth signal identified itself as being a standard locator at ... train station, and it said it was at geographic location ..., ...' And later another program might come around and lossily or losslessly compress certain portions of the memory to save space. eg: 'geographic location ...' might be a high precision number, and might instead be transformed into a location name or id which is smaller, or visa versa; or the part about wifi ssids and their strengths might be superfluous and be deleted since their value was only in relation to location detection. Over time the whole memory might be compressed to something like 'was at ... train station'

Note: in the eg above, classification of a code is equivalent to subsetting, and the program that runs on the code interprets one representation to another

After the code is interpreted by the program on your phone, it shows information that isn't immediately understood by the phone, so the phone automatically looks up on several directories online what the information might mean. One directory has that information stored along with a program that should be used when the code is read. The phone downloads the program and runs it on the information (this is assuming heavy sandboxing somehow). The program now is designed to request the local name of the connected automated service in the station for ticketing and logistics from the locally connected router, the router sees the request but because of a version mismatch doesn't know how to respond, the program then goes online and tries to connected with the website of the transportation service, but the website has changed names and so the program cant connect, then the program looks to a list of preprogrammed directory services online for the name of the transportation service website, some directories recommend some other directories, along with programs used to comprehend those directories formats. Finally the program finds the website from a directory, connects to the website, sends a standard request, the website returns the ip for the local transportation service server, the program connects and sends a request for information and sustained connection. The user is prompted for their destination, credentials, etc, which they input. Then the program received information back from the transport server. In that information packet is an object typed in a standard way for geographic information. The user taps on that and the phone looks at which programs can use that type of object along with user preferences. It opens the geo object in a mapping software which cracks the object open. Inside the object is information about a route. The route contains nodes which are labeled with space, and going by the object's declared type the software knows how to use these nodes to make a representation of the route

* Objects which can be queried for information are more flexible than objects with fail-on-semantic-mismatch (eg: `geo.route` which fails now or later if the system can't work with a nonexistant or null value, vs `geo['route']` which may explicitly not exist). Furthermore, objects may have different naming schemes, so a program trying to get a route from an object may not get it with `geo.route`, or `geo.Route`, or `geo.my_route`, but instead may have to look up the object's declared type
* An object may have a declared type, which could be useful for looking up how to do various things. eg: an object may have an `org.dienfadsu.myOwn_map` type instead of a `route` type, though they are otherwise equivalent. Later, an object that is unknown by a program might be looked up on a directory which also doesn't know the object, then the program uploads the member names of the object, along with some public identifiers, to the directory which then does a search for possible mis-declared-type objects by member name, and failing that stores a record for that object as it was uploaded and does searches for synonyms for each member name
* Every time the software looks up an object in a directory or information service, the mappings between unknown and known members, types, etc that it receives from these services are stored, and later it won't have to look those things up again




